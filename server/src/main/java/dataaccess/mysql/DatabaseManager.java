package dataaccess.mysql;

import chess.ChessGame;
import dataaccess.DataAccessException;
import serial.Serializer;

import java.sql.*;
import java.util.Properties;

import static java.sql.Types.VARCHAR;

public final
class DatabaseManager {
    private static final String DATABASE_NAME;
    private static final String USER;
    private static final String PASSWORD;
    private static final String CONNECTION_URL;

    /*
     * Load the database information for the db.properties file.
     */
    static {
        try {
            try (var propStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("db.properties")) {
                if (propStream == null) {
                    throw new Exception("Unable to load db.properties");
                }
                Properties props = new Properties();
                props.load(propStream);
                DATABASE_NAME = props.getProperty("db.name");
                USER = props.getProperty("db.user");
                PASSWORD = props.getProperty("db.password");

                var host = props.getProperty("db.host");
                var port = Integer.parseInt(props.getProperty("db.port"));
                CONNECTION_URL = String.format("jdbc:mysql://%s:%d", host, port);
            }
        } catch (Exception ex) {
            throw new RuntimeException("unable to process db.properties. " + ex.getMessage());
        }
    }

    /**
     * Creates the database if it does not already exist.
     */
    static
    void createDatabase() throws DataAccessException {
        try {
            var statement = "CREATE DATABASE IF NOT EXISTS " + DATABASE_NAME;
            var conn = DriverManager.getConnection(CONNECTION_URL, USER, PASSWORD);
            try (var preparedStatement = conn.prepareStatement(statement)) {
                preparedStatement.executeUpdate();
            }
        } catch (SQLException e) {
            throw new DataAccessException(e.getMessage());
        }
    }

    /**
     * Create a connection to the database and sets the catalog based upon the properties specified in db.properties.
     * Connections to the database should be short-lived, and you must close the connection when you are done with it.
     * The easiest way to do that is with a try-with-resource block. <br/>
     * <code>
     * try (var conn = DbInfo.getConnection(databaseName)) { // execute SQL statements. }
     * </code>
     */
    static
    Connection getConnection() throws DataAccessException {
        try {
            var conn = DriverManager.getConnection(CONNECTION_URL, USER, PASSWORD);
            conn.setCatalog(DATABASE_NAME);
            return conn;
        } catch (SQLException e) {
            throw new DataAccessException(e.getMessage());
        }
    }

    static
    void configureDatabase(String[] createStatements) throws DataAccessException {
        DatabaseManager.createDatabase();
        try (var conn = DatabaseManager.getConnection()) {
            for (var statement : createStatements) {
                try (var preparedStatement = conn.prepareStatement(statement)) {
                    preparedStatement.executeUpdate();
                }
            }
        } catch (SQLException e) {
            throw new DataAccessException(String.format("Error: failed to configure database: %s", e.getMessage()));
        }

    }

    /**
     * Executes an SQL statement.
     *
     * @param sql    The SQL to execute
     * @param params The objects to fill the SQL statement
     *
     * @return Any primary keys generated by the database. <code>0</code> if there were no primary keys generated.
     *
     * @throws DataAccessException if there is a failure to execute the sql.
     */
    static
    int executeUpdate(String sql, Object... params) throws DataAccessException {
        try (var conn = DatabaseManager.getConnection()) {
            try (var statement = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
                loadParamsToStatement(params, statement);

                statement.executeUpdate();

                var resultSet = statement.getGeneratedKeys();
                if (resultSet.next()) {
                    return resultSet.getInt(1);
                }

                return 0;
            }
        } catch (SQLException e) {
            throw new DataAccessException(String.format("Error: failed to execute sql: %s", e.getMessage()));
        }
    }

    private static
    void loadParamsToStatement(Object[] params, PreparedStatement statement) throws SQLException {
        for (int i = 0; i < params.length; i++) {
            var param = params[i];
            switch (param) {
                case null -> statement.setNull(i + 1, VARCHAR);
                case String p -> statement.setString(i + 1, p);
                case Integer p -> statement.setInt(i + 1, p);
                case ChessGame p -> statement.setString(i + 1, Serializer.serialize(p));
                default -> {
                }
            }
        }
    }

}
